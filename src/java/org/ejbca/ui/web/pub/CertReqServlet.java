/*************************************************************************
 *                                                                       *
 *  EJBCA: The OpenSource Certificate Authority                          *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
 
package org.ejbca.ui.web.pub;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.ejb.EJBException;
import javax.ejb.ObjectNotFoundException;
import javax.naming.InitialContext;
import javax.rmi.PortableRemoteObject;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.fileupload.DiskFileUpload;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUpload;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.ejbca.core.ejb.ServiceLocator;
import org.ejbca.core.ejb.ca.sign.ISignSessionLocal;
import org.ejbca.core.ejb.ca.sign.ISignSessionLocalHome;
import org.ejbca.core.ejb.ca.store.ICertificateStoreSessionHome;
import org.ejbca.core.ejb.ca.store.ICertificateStoreSessionRemote;
import org.ejbca.core.ejb.ra.IUserAdminSessionHome;
import org.ejbca.core.ejb.ra.IUserAdminSessionRemote;
import org.ejbca.core.ejb.ra.raadmin.IRaAdminSessionHome;
import org.ejbca.core.ejb.ra.raadmin.IRaAdminSessionRemote;
import org.ejbca.core.model.InternalResources;
import org.ejbca.core.model.SecConst;
import org.ejbca.core.model.ca.AuthLoginException;
import org.ejbca.core.model.ca.AuthStatusException;
import org.ejbca.core.model.ca.SignRequestException;
import org.ejbca.core.model.ca.SignRequestSignatureException;
import org.ejbca.core.model.ca.catoken.CATokenConstants;
import org.ejbca.core.model.ca.catoken.CATokenOfflineException;
import org.ejbca.core.model.log.Admin;
import org.ejbca.core.model.ra.UserDataConstants;
import org.ejbca.core.model.ra.UserDataVO;
import org.ejbca.core.model.ra.raadmin.EndEntityProfile;
import org.ejbca.core.model.util.GenerateToken;
import org.ejbca.cvc.CAReferenceField;
import org.ejbca.cvc.CVCertificate;
import org.ejbca.cvc.CertificateParser;
import org.ejbca.cvc.HolderReferenceField;
import org.ejbca.ui.web.RequestHelper;
import org.ejbca.util.Base64;
import org.ejbca.util.CertTools;
import org.ejbca.util.FileTools;
import org.ejbca.util.keystore.KeyTools;



/**
 * Servlet used to install a private key with a corresponding certificate in a browser. A new
 * certificate is installed in the browser in following steps:<br>
 * 1. The key pair is generated by the browser. <br>
 * 2. The public part is sent to the servlet in a POST together with user info ("pkcs10|keygen",
 * "inst", "user", "password"). For internet explorer the public key is sent as a PKCS10
 * certificate request. <br>
 * 3. The new certificate is created by calling the RSASignSession session bean. <br>
 * 4. A page containing the new certificate and a script that installs it is returned to the
 * browser. <br>
 * 
 * <p></p>
 * 
 * <p>
 * The following initiation parameters are needed by this servlet: <br>
 * "responseTemplate" file that defines the response to the user (IE). It should have one line
 * with the text "cert =". This line is replaced with the new certificate. "keyStorePass".
 * Password needed to load the key-store. If this parameter is none existing it is assumed that no
 * password is needed. The path could be absolute or relative.<br>
 * </p>
 *
 * @author Original code by Lars Silven
 * @version $Id$
 */
public class CertReqServlet extends HttpServlet {
    private static final Logger log = Logger.getLogger(CertReqServlet.class);
    /** Internal localization of logs and errors */
    private static final InternalResources intres = InternalResources.getInstance();

    private static final byte[] BAG_ATTRIBUTES =    "Bag Attributes\n".getBytes();
    private static final byte[] FRIENDLY_NAME =     "    friendlyName: ".getBytes();
    private static final byte[] SUBJECT_ATTRIBUTE = "subject=/".getBytes();
    private static final byte[] ISSUER_ATTRIBUTE =  "issuer=/".getBytes();
    private static final byte[] BEGIN_CERTIFICATE = "-----BEGIN CERTIFICATE-----".getBytes();
    private static final byte[] END_CERTIFICATE =   "-----END CERTIFICATE-----".getBytes();
    private static final byte[] BEGIN_PRIVATE_KEY = "-----BEGIN PRIVATE KEY-----".getBytes();
    private static final byte[] END_PRIVATE_KEY =   "-----END PRIVATE KEY-----".getBytes();
    private static final byte[] NL = "\n".getBytes();

    private IUserAdminSessionHome useradminhome = null;
    private ICertificateStoreSessionHome storehome = null;
    private IRaAdminSessionHome raadminhome = null;

    private ISignSessionLocal signsession = null;

    private synchronized ISignSessionLocal getSignSession(){
    	if(signsession == null){	
    		try {
    			ISignSessionLocalHome signhome = (ISignSessionLocalHome)ServiceLocator.getInstance().getLocalHome(ISignSessionLocalHome.COMP_NAME);
    			signsession = signhome.create();
    		}catch(Exception e){
    			throw new EJBException(e);      	  	    	  	
    		}
    	}
    	return signsession;
    }
    
    /**
     * Servlet init
     *
     * @param config servlet configuration
     *
     * @throws ServletException on error
     */
    public void init(ServletConfig config) throws ServletException {
        super.init(config);

        try {
            // Install BouncyCastle provider
            CertTools.installBCProvider();

            // Get EJB context and home interfaces
            InitialContext ctx = new InitialContext();
            useradminhome = (IUserAdminSessionHome) PortableRemoteObject.narrow(
                             ctx.lookup(IUserAdminSessionHome.JNDI_NAME), IUserAdminSessionHome.class );
            raadminhome   = (IRaAdminSessionHome) PortableRemoteObject.narrow(
                             ctx.lookup(IRaAdminSessionHome.JNDI_NAME), IRaAdminSessionHome.class );            
            storehome   = (ICertificateStoreSessionHome) PortableRemoteObject.narrow(
                    ctx.lookup(ICertificateStoreSessionHome.JNDI_NAME), ICertificateStoreSessionHome.class );            
        } catch( Exception e ) {
            throw new ServletException(e);
        }
    }

    private class RequestInstance{

    	RequestInstance(){}

    	void doPost(HttpServletRequest request, HttpServletResponse response)
        throws IOException, ServletException {
        	
        	ServletDebug debug = new ServletDebug(request, response);
            boolean usekeyrecovery = false;

            RequestHelper.setDefaultCharacterEncoding(request);
            String iErrorMessage = null;
            try {
            	setParameters(request);
            	
                String username = getParameter("user");
                String password = getParameter("password");
                String keylengthstring = getParameter("keylength");
                String keyalgstring = getParameter("keyalg");
                String openvpn = getParameter("openvpn");
                String certprofile = getParameter("certprofile");
    			String keylength = "1024";
    			String keyalg = CATokenConstants.KEYALGORITHM_RSA;
    			
                int resulttype = 0;
                if(getParameter("resulttype") != null)
                  resulttype = Integer.parseInt(getParameter("resulttype")); // Indicates if certificate or PKCS7 should be returned on manual PKCS10 request.
                

                String classid = "clsid:127698e4-e730-4e5c-a2b1-21490a70c8a1\" CODEBASE=\"/CertControl/xenroll.cab#Version=5,131,3659,0";

                if ((getParameter("classid") != null) &&
                        !getParameter("classid").equals("")) {
                    classid = getParameter("classid");
                }

                if (keylengthstring != null) {
                    keylength = keylengthstring;
                }
                if (keyalgstring != null) {
                    keyalg = keyalgstring;
                }

                Admin administrator = new Admin(Admin.TYPE_PUBLIC_WEB_USER, request.getRemoteAddr());

                IUserAdminSessionRemote adminsession = useradminhome.create();
                ICertificateStoreSessionRemote storesession = storehome.create();
                IRaAdminSessionRemote raadminsession = raadminhome.create();            
                ISignSessionLocal signsession = getSignSession();
                RequestHelper helper = new RequestHelper(administrator, debug);

                log.info(intres.getLocalizedMessage("certreq.receivedcertreq", username, request.getRemoteAddr()));
                debug.print("Username: " + username);

                // Check user
                int tokentype = SecConst.TOKEN_SOFT_BROWSERGEN;

                usekeyrecovery = (raadminsession.loadGlobalConfiguration(administrator)).getEnableKeyRecovery();

                UserDataVO data = adminsession.findUser(administrator, username);

                if (data == null) {
                    throw new ObjectNotFoundException();
                }

                boolean savekeys = data.getKeyRecoverable() && usekeyrecovery &&  (data.getStatus() != UserDataConstants.STATUS_KEYRECOVERY);
                boolean loadkeys = (data.getStatus() == UserDataConstants.STATUS_KEYRECOVERY) && usekeyrecovery;

                int endEntityProfileId = data.getEndEntityProfileId();
                int certificateProfileId = data.getCertificateProfileId();
                EndEntityProfile endEntityProfile = raadminsession.getEndEntityProfile(administrator, endEntityProfileId);
                boolean reusecertificate = endEntityProfile.getReUseKeyRevoceredCertificate();
                // Set a new certificate profile, if we have requested one specific
                if (StringUtils.isNotEmpty(certprofile)) {
                	boolean clearpwd = StringUtils.isNotEmpty(data.getPassword());
                	int id = storesession.getCertificateProfileId(administrator, certprofile);
                	// Change the value if there exists a certprofile with the requested name, and it is not the same as 
                	// the one already registered to be used by default
                	if ( (id > 0) ) {
                		if (id != certificateProfileId) {
                    		// Check if it is in allowed profiles in the entity profile
                    		Collection c = endEntityProfile.getAvailableCertificateProfileIds();
                    		if (c.contains(String.valueOf(id))) {
                            	data.setCertificateProfileId(id);
                            	// This admin can be the public web user, which may not be allowed to change status,
                            	// this is a bit ugly, but what can a man do...
                            	Admin tempadmin = new Admin(Admin.TYPE_INTERNALUSER);
                            	adminsession.changeUser(tempadmin, data, clearpwd);            		            			
                    		} else {
                    			String defaultCertificateProfileName = storesession.getCertificateProfileName(administrator, certificateProfileId);
                        		log.info(intres.getLocalizedMessage("certreq.badcertprofile", certprofile, defaultCertificateProfileName));
                    		}
                		}
                	} else {
            			String defaultCertificateProfileName = storesession.getCertificateProfileName(administrator, certificateProfileId);
                		log.info(intres.getLocalizedMessage("certreq.nosuchcertprofile", certprofile, defaultCertificateProfileName));
                	}
                }

                // get users Token Type.
                tokentype = data.getTokenType();
                GenerateToken tgen = new GenerateToken(true);
                if(tokentype == SecConst.TOKEN_SOFT_P12){
                  KeyStore ks = tgen.generateOrKeyRecoverToken(administrator, username, password, data.getCAId(), keylength, keyalg, false, loadkeys, savekeys, reusecertificate, endEntityProfileId);
                  if (StringUtils.equals(openvpn, "on")) {            	  
                      sendOpenVPNToken(ks, username, password, response);
                  } else {
                	  sendP12Token(ks, username, password, response);
                  }
                }
                if(tokentype == SecConst.TOKEN_SOFT_JKS){
                  KeyStore ks = tgen.generateOrKeyRecoverToken(administrator, username, password, data.getCAId(), keylength, keyalg, true, loadkeys, savekeys, reusecertificate, endEntityProfileId);
                  sendJKSToken(ks, username, password, response);
                }
                if(tokentype == SecConst.TOKEN_SOFT_PEM){
                  KeyStore ks = tgen.generateOrKeyRecoverToken(administrator, username, password, data.getCAId(), keylength, keyalg, false, loadkeys, savekeys, reusecertificate, endEntityProfileId);
                  sendPEMTokens(ks, username, password, response);
                }
                if(tokentype == SecConst.TOKEN_SOFT_BROWSERGEN){

                  // first check if it is a Firefox request,
                  if (getParameter("keygen") != null) {
                      byte[] reqBytes=getParameter("keygen").getBytes();
                      if ((reqBytes != null) && (reqBytes.length>0)) {
                          log.debug("Received NS request: "+new String(reqBytes));
                          byte[] certs = helper.nsCertRequest(signsession, reqBytes, username, password);
                          RequestHelper.sendNewCertToNSClient(certs, response);
                      } else {
                    	  throw new SignRequestException("No request bytes received.");
                      }
                  } else if ( getParameter("iidPkcs10") != null && !getParameter("iidPkcs10").equals("")) {
                      // NetID iid?
                      byte[] reqBytes = getParameter("iidPkcs10").getBytes();
                      if ((reqBytes != null) && (reqBytes.length>0)) {
                          log.debug("Received iidPkcs10 request: "+new String(reqBytes));
                          byte[] b64cert=helper.pkcs10CertRequest(signsession, reqBytes, username, password, RequestHelper.ENCODED_CERTIFICATE, false);
                          response.setContentType("text/html");
                          RequestHelper.sendNewCertToIidClient(b64cert, request, response.getOutputStream(), getServletContext(), getInitParameter("responseIidTemplate"),classid);
                      } else {
                    	  throw new SignRequestException("No request bytes received.");
                      }
                  } else if ( (getParameter("pkcs10") != null) || (getParameter("PKCS10") != null) ) {
                      // if not firefox, check if it's IE
                      byte[] reqBytes = getParameter("pkcs10").getBytes();
                      if (reqBytes == null)
                          reqBytes=getParameter("PKCS10").getBytes();
                      if ((reqBytes != null) && (reqBytes.length>0)) {
                          log.debug("Received IE request: "+new String(reqBytes));
                          byte[] b64cert=helper.pkcs10CertRequest(signsession, reqBytes, username, password, RequestHelper.ENCODED_PKCS7);
                          debug.ieCertFix(b64cert);
                          RequestHelper.sendNewCertToIEClient(b64cert, response.getOutputStream(), getServletContext(), getInitParameter("responseTemplate"),classid);
                      } else {
                    	  throw new SignRequestException("No request bytes received.");
                      }
                  } else if ( ((getParameter("pkcs10req") != null) || (getParameter("pkcs10file") != null)) && resulttype != 0) {
                	  byte[] reqBytes = null;
                	  String pkcs10req = getParameter("pkcs10req");
            		  if (StringUtils.isEmpty(pkcs10req)) {
                		  // did we upload a file instead?
                		  log.debug("No pasted request received, checking for uploaded file.");
                		  pkcs10req = getParameter("pkcs10file");
                		  if (StringUtils.isNotEmpty(pkcs10req)) {
                			  // The uploaded file has been converted to a base64 encoded string
                			  reqBytes = Base64.decode(pkcs10req.getBytes());
                			  
                		  }
                	  } else {
                    	  reqBytes=pkcs10req.getBytes(); // The pasted request            		  
                	  }
                	  
                      if ((reqBytes != null) && (reqBytes.length>0)) {
                          pkcs10Req(response, username, password, resulttype, signsession, helper, reqBytes);
                      } else {
                    	  throw new SignRequestException("No request bytes received.");
                      }
                  } else if ( ((getParameter("cvcreq") != null) || (getParameter("cvcreqfile") != null)) && resulttype != 0) {
                      // It's a CVC certificate request (EAC ePassports)
                	  byte[] reqBytes = null;
                	  String req = getParameter("cvcreq");
            		  if (StringUtils.isEmpty(req)) {
                		  // did we upload a file instead?
                		  log.debug("No pasted request received, checking for uploaded file.");
                		  req = getParameter("cvcreqfile");
                		  if (StringUtils.isNotEmpty(req)) {
                			  // The uploaded file has been converted to a base64 encoded string
                			  reqBytes = Base64.decode(req.getBytes());
                			  
                		  }
                	  } else {
                    	  reqBytes=req.getBytes(); // The pasted request            		  
                	  }

                      if ((reqBytes != null) && (reqBytes.length>0)) {
                          log.debug("Received CVC request: "+new String(reqBytes));
                          byte[] b64cert=helper.cvcCertRequest(signsession, reqBytes, username, password);
                          CVCertificate cvccert = (CVCertificate) CertificateParser.parseCVCObject(Base64.decode(b64cert));
                          String filename = "";
                          CAReferenceField carf = cvccert.getCertificateBody().getAuthorityReference();
                          if (carf != null) {
                              String car = carf.getConcatenated();
                        	  filename += car;
                          }
                          HolderReferenceField chrf = cvccert.getCertificateBody().getHolderReference();
                          if (chrf != null) {
                              String chr = chrf.getConcatenated();
                              if (filename.length() > 0) {
                            	  filename += "_";
                              }
                              filename +=chr;
                          }
                          if (filename.length() == 0) {
                        	  filename = username;
                          }
                          log.debug("Filename: "+filename);
                          if(resulttype == RequestHelper.BINARY_CERTIFICATE)  
                            RequestHelper.sendBinaryBytes(Base64.decode(b64cert), response, "application/octet-stream", filename+".cvcert");
                          if(resulttype == RequestHelper.ENCODED_CERTIFICATE)
                            RequestHelper.sendNewB64File(b64cert, response, filename+".pem", RequestHelper.BEGIN_CERTIFICATE_WITH_NL, RequestHelper.END_CERTIFICATE_WITH_NL);
                      } else {
                    	  throw new SignRequestException("No request bytes received.");
                      }
                  }
                }
            } catch (ObjectNotFoundException oe) {
            	iErrorMessage = intres.getLocalizedMessage("certreq.nosuchusername");
            } catch (AuthStatusException ase) {
            	iErrorMessage = intres.getLocalizedMessage("certreq.wrongstatus");
            } catch (AuthLoginException ale) {
            	iErrorMessage = intres.getLocalizedMessage("certreq.wrongpassword");
            } catch (SignRequestException re) {
            	iErrorMessage = intres.getLocalizedMessage("certreq.invalidreq", re.getMessage());
            } catch (SignRequestSignatureException se) {
            	String iMsg = intres.getLocalizedMessage("certreq.invalidsign");
                log.error(iMsg, se);
                debug.printMessage(iMsg);
                debug.printDebugInfo();
                return;
            } catch (ArrayIndexOutOfBoundsException ae) {
            	iErrorMessage = intres.getLocalizedMessage("certreq.invalidreq");
            } catch (org.ejbca.core.model.ca.IllegalKeyException e) {
            	iErrorMessage = intres.getLocalizedMessage("certreq.invalidkey", e.getMessage());
            } catch (Exception e) {
            	Throwable e1 = e.getCause();
            	if (e1 instanceof CATokenOfflineException) {
                	String iMsg = intres.getLocalizedMessage("certreq.catokenoffline", e1.getMessage());
    	            // this is already logged as an error, so no need to log it one more time
    	            debug.printMessage(iMsg);
    	            debug.printDebugInfo();
    	            return;				
    			} else {
    				if (e1 == null) e1 = e;
                	String iMsg = intres.getLocalizedMessage("certreq.errorgeneral", e1.getMessage());
    	            log.debug(iMsg, e);
                	iMsg = intres.getLocalizedMessage("certreq.parameters", e1.getMessage());
    	            debug.print(iMsg + ":\n");
    	            Set paramNames = params.keySet();
    	            Iterator iter = paramNames.iterator();
    	            while (iter.hasNext()) {
    	                String name = (String)iter.next();
    	                String parameter = getParameter(name);
    	                if (!StringUtils.equals(name, "password")) {
    	                    debug.print(name + ": '" + parameter + "'\n");                	
    	                } else {
    	                	debug.print(name + ": <hidden>\n");
    	                }
    	            }
    	            debug.takeCareOfException(e);
    	            debug.printDebugInfo();
    			}
            }
            if (iErrorMessage != null) {
                log.debug(iErrorMessage);
                debug.printMessage(iErrorMessage);
                debug.printDebugInfo();
                return;
            }
        }
        private Map params = null;

        /** Method creating a Map of request values, designed to handle both regular 
         * x-encoded forms and multipart encoded upload forms. 
         * 
         * @param request HttpServletRequest
         * @throws FileUploadException if multipart request can not be parsed
         * @throws IOException If input stream of uploaded object can not be read 
         */
        private void setParameters(HttpServletRequest request) throws FileUploadException, IOException {
        	if (FileUpload.isMultipartContent(request)) {     
        		params = new HashMap();
        		DiskFileUpload upload = new DiskFileUpload();
        		upload.setSizeMax(10000);                   
        		upload.setSizeThreshold(9999);
        		List items;
        		items = upload.parseRequest(request);
        		Iterator iter = items.iterator();
        		while (iter.hasNext()) {     
        			FileItem item = (FileItem) iter.next();
        			if (item.isFormField()) {
        				params.put(item.getFieldName(), item.getString());
        			} else {
        				InputStream is = item.getInputStream();
        				byte[] bytes = FileTools.readInputStreamtoBuffer(is);
        				params.put(item.getFieldName(), new String(Base64.encode(bytes)));
        			}
        		}
        	} else {
        		params = request.getParameterMap();  		  
        	}
        }
        private String getParameter(String param) {
        	String ret = null;
        	Object o = params.get(param);
        	if (o != null) {
        		if (o instanceof String) {
            		ret = (String)o;    			
        		} else if (o instanceof String[]) { // keygen is of this type for some reason...
        			String[] str = (String[])o;
        			if ( (str != null) && (str.length>0) ) {
            			ret = str[0];    				
        			}
        		} else {
        			log.debug("Can not cast object of type: "+o.getClass().getName());    			
        		}
        	}
        	return ret;
        }

    	private void pkcs10Req(HttpServletResponse response, String username,
    			String password, int resulttype, ISignSessionLocal signsession,
    			RequestHelper helper, byte[] reqBytes) throws Exception,
    			IOException {
    		log.debug("Received PKCS10 request: "+new String(reqBytes));
    		  byte[] b64cert=helper.pkcs10CertRequest(signsession, reqBytes, username, password, resulttype);
    		  if(resulttype == RequestHelper.ENCODED_PKCS7)  
    		    RequestHelper.sendNewB64Cert(b64cert, response, RequestHelper.BEGIN_PKCS7_WITH_NL, RequestHelper.END_PKCS7_WITH_NL);
    		  if(resulttype == RequestHelper.ENCODED_CERTIFICATE)
    		    RequestHelper.sendNewB64Cert(b64cert, response, RequestHelper.BEGIN_CERTIFICATE_WITH_NL, RequestHelper.END_CERTIFICATE_WITH_NL);
    	}
        /**
         * method to create an install package for OpenVPN including keys and send to user.
         * Contributed by: Jon Bendtsen, jon.bendtsen(at)laerdal.dk
         */
        private void sendOpenVPNToken(KeyStore ks, String username, String kspassword, HttpServletResponse out) throws Exception {
        	ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        	ks.store(buffer, kspassword.toCharArray());
        	
        	File fout = new File("/usr/local/tmp/" + username + ".p12");
        	FileOutputStream certfile = new FileOutputStream(fout);
        	
        	Enumeration en = ks.aliases();
        	String alias = (String)en.nextElement();
        	// Then get the certificates
        	Certificate[] certs = KeyTools.getCertChain(ks, alias);
        	// The first  one (certs[0]) is the users cert and the last
        	// one (certs [certs.lenght-1]) is the CA-cert
        	X509Certificate x509cert = (X509Certificate) certs[0];
        	String IssuerDN = x509cert.getIssuerDN().toString();
        	String SubjectDN = x509cert.getSubjectDN().toString();
        	
        	// export the users certificate to file
        	buffer.writeTo(certfile);
        	buffer.flush();
        	buffer.close();
        	certfile.close();
        	
        	// run shell script, which will also remove the created files
        	// parameters are the username, IssuerDN and SubjectDN
        	// IssuerDN and SubjectDN will be used to select the right
        	// openvpn configuration file
        	// they have to be written to stdin of the script to support
        	// spaces in the username, IssuerDN or SubjectDN
        	Runtime rt = Runtime.getRuntime();
        	if (rt==null) {
        		log.error(intres.getLocalizedMessage("certreq.ovpntnoruntime"));
        	} else {
        		final String script = "/usr/local/ejbca/bin/mk_openvpn_" + "windows_installer.sh";
        		Process p = rt.exec(script);
        		if (p==null) {
            		log.error(intres.getLocalizedMessage("certreq.ovpntfailedexec", script));
        		} else {
        			OutputStream pstdin = p.getOutputStream();
        			PrintStream stdoutp = new PrintStream(pstdin);
        			stdoutp.println(username);
        			stdoutp.println(IssuerDN);
        			stdoutp.println(SubjectDN);
        			stdoutp.flush();
        			stdoutp.close();
        			pstdin.close();
        			int exitVal = p.waitFor();
        			if (exitVal != 0) {
                		log.error(intres.getLocalizedMessage("certreq.ovpntexiterror", exitVal));
        			} else {
                		log.debug(intres.getLocalizedMessage("certreq.ovpntexiterror", exitVal));
        			}
        		}
        	}
        	
        	// we ought to check if the script was okay or not, but in a little
        	// while we will look for the openvpn-gui-install-$username.exe
        	// and fail there if the script failed. Also, one could question
        	// what to do if it did fail, serve the user the certificate?
        	
        	// sending the OpenVPN windows installer
        	String filename = "openvpn-gui-install-" + username + ".exe";
        	File fin =  new File("/usr/local/tmp/" + filename);
        	FileInputStream vpnfile = new FileInputStream(fin);
        	
        	out.setContentType("application/x-msdos-program");
        	out.setHeader("Content-disposition", "filename=" + filename);
    		out.setContentLength( new Long(fin.length()).intValue() );
    		OutputStream os = out.getOutputStream(); 
        	byte[] buf = new byte[4096];
        	int offset = 0;
        	int bytes = 0;
        	while ( (bytes=vpnfile.read(buf)) != -1 ) {
        		os.write(buf,0,bytes);
        		offset += bytes;
        	}
        	vpnfile.close();
        	// delete OpenVPN windows installer, the script will delete cert.
        	fin.delete();
        	out.flushBuffer();    	
        } // sendOpenVPNToken
        
        private void sendP12Token(KeyStore ks, String username, String kspassword,
            HttpServletResponse out) throws Exception {
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            ks.store(buffer, kspassword.toCharArray());

            out.setContentType("application/x-pkcs12");
            out.setHeader("Content-disposition", "filename=" + username + ".p12");
            out.setContentLength(buffer.size());
            buffer.writeTo(out.getOutputStream());
            out.flushBuffer();
            buffer.close();
        }

        private void sendJKSToken(KeyStore ks, String username, String kspassword,
            HttpServletResponse out) throws Exception {
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            ks.store(buffer, kspassword.toCharArray());

            out.setContentType("application/octet-stream");
            out.setHeader("Content-disposition", "filename=" + username + ".jks");
            out.setContentLength(buffer.size());
            buffer.writeTo(out.getOutputStream());
            out.flushBuffer();
            buffer.close();
        }

        private void sendPEMTokens(KeyStore ks, String username, String kspassword,
            HttpServletResponse out) throws Exception {
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            String alias = "";

            // Find the key private key entry in the keystore
            Enumeration e = ks.aliases();
            Object o = null;
            PrivateKey serverPrivKey = null;

            while (e.hasMoreElements()) {
                o = e.nextElement();

                if (o instanceof String) {
                    if ((ks.isKeyEntry((String) o)) &&
                            ((serverPrivKey = (PrivateKey) ks.getKey((String) o,
                                    kspassword.toCharArray())) != null)) {
                        alias = (String) o;

                        break;
                    }
                }
            }

            byte[] privKeyEncoded = "".getBytes();

            if (serverPrivKey != null) {
                privKeyEncoded = serverPrivKey.getEncoded();
            }

            //Certificate chain[] = ks.getCertificateChain((String) o);
            Certificate[] chain = KeyTools.getCertChain(ks, (String) o);
            X509Certificate userX509Certificate = (X509Certificate) chain[0];

            byte[] output = userX509Certificate.getEncoded();
            String sn = CertTools.getSubjectDN(userX509Certificate);

            String subjectdnpem = sn.replace(',', '/');
            String issuerdnpem = CertTools.getIssuerDN(userX509Certificate).replace(',', '/');

            buffer.write(BAG_ATTRIBUTES);
            buffer.write(FRIENDLY_NAME);
            buffer.write(alias.getBytes());
            buffer.write(NL);
            buffer.write(BEGIN_PRIVATE_KEY);
            buffer.write(NL);

            byte[] privKey = Base64.encode(privKeyEncoded);
            buffer.write(privKey);
            buffer.write(NL);
            buffer.write(END_PRIVATE_KEY);
            buffer.write(NL);
            buffer.write(BAG_ATTRIBUTES);
            buffer.write(FRIENDLY_NAME);
            buffer.write(alias.getBytes());
            buffer.write(NL);
            buffer.write(SUBJECT_ATTRIBUTE);
            buffer.write(subjectdnpem.getBytes());
            buffer.write(NL);
            buffer.write(ISSUER_ATTRIBUTE);
            buffer.write(issuerdnpem.getBytes());
            buffer.write(NL);
            buffer.write(BEGIN_CERTIFICATE);
            buffer.write(NL);

            byte[] userCertB64 = Base64.encode(output);
            buffer.write(userCertB64);
            buffer.write(NL);
            buffer.write(END_CERTIFICATE);
            buffer.write(NL);

            if (CertTools.isSelfSigned(userX509Certificate)) {
            } else {
                for (int num = 1; num < chain.length; num++) {
                    X509Certificate tmpX509Cert = (X509Certificate) chain[num];
                    sn = CertTools.getSubjectDN(tmpX509Cert);

                    String cn = CertTools.getPartFromDN(sn, "CN");
                    if (StringUtils.isEmpty(cn)) {
                    	cn="Unknown";
                    }

                    subjectdnpem = sn.replace(',', '/');
                    issuerdnpem = CertTools.getIssuerDN(tmpX509Cert).replace(',', '/');

                    buffer.write(BAG_ATTRIBUTES);
                    buffer.write(FRIENDLY_NAME);
                    buffer.write(cn.getBytes());
                    buffer.write(NL);
                    buffer.write(SUBJECT_ATTRIBUTE);
                    buffer.write(subjectdnpem.getBytes());
                    buffer.write(NL);
                    buffer.write(ISSUER_ATTRIBUTE);
                    buffer.write(issuerdnpem.getBytes());
                    buffer.write(NL);

                    byte[] tmpOutput = tmpX509Cert.getEncoded();
                    buffer.write(BEGIN_CERTIFICATE);
                    buffer.write(NL);

                    byte[] tmpCACertB64 = Base64.encode(tmpOutput);
                    buffer.write(tmpCACertB64);
                    buffer.write(NL);
                    buffer.write(END_CERTIFICATE);
                    buffer.write(NL);
                }
            }

            out.setContentType("application/octet-stream");
            out.setHeader("Content-disposition", " attachment; filename=" + username + ".pem");
            buffer.writeTo(out.getOutputStream());
            out.flushBuffer();
            buffer.close();
        }

    }

    /**
     * Handles HTTP POST
     *
     * @param request servlet request
     * @param response servlet response
     *
     * @throws IOException input/output error
     * @throws ServletException on error
     */
    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws IOException, ServletException {
        //doPost
    	new RequestInstance().doPost(request, response);
    }

    /**
     * Handles HTTP GET
     *
     * @param request servlet request
     * @param response servlet response
     *
     * @throws IOException input/output error
     * @throws ServletException on error
     */
    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws IOException, ServletException {
        log.trace(">doGet()");
        response.setHeader("Allow", "POST");

        ServletDebug debug = new ServletDebug(request, response);
    	String iMsg = intres.getLocalizedMessage("certreq.postonly");
        debug.print(iMsg);
        debug.printDebugInfo();
        log.trace("<doGet()");
    }
    // doGet

}
// CertReqServlet
